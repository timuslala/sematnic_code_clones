# Code Clone Detection - Project Overview

This repository reproduces two methods for detecting cloned code fragments.  
**Additional goal that became main goal:** After analyzing the data, we discovered that the BigCloneBench dataset contains many examples that are not marked as clones, even though they are actually Type-4 (semantic) clones.

---

## Current Best Approach

One of the methods to see which code snippets are clones and which are not is clustering (KNN) based on embeddings of short code fragment descriptions generated by a Large Language Model (LLM).

![Clusterization Results](clusterization_results.png)

- **False positives:** Examples labeled as clones in the dataset, but clustering and cosine similarity suggest they are not.
- **False negatives:** Examples labeled as non-clones in the dataset, but clustering and cosine similarity suggest they are clones.
- **Dataset size:** 540,000 records

---

## How to Reproduce the Results

**Google Drive with data:**  
https://drive.google.com/drive/u/1/folders/1DKLOvjTinMGJLjMlA5YTlAaBtNWju8jb

### Steps:

1. Download this repository.
2. Restore the Python environment using `pyproject.toml`.
   - **Tip:** To skip steps 3-8 (which are time-consuming), download `BCB_updated.pkl` from the Google Drive above and place it in the `./old` folder.
3. Download the initial dataset `id2sourcecode.zip` and label files `BCB_clone.csv` and `BCB_nonclone.csv` from Google Drive.
4. Unpack the dataset to `./old/dataset/id2sourcecode`.
5. Place the `.csv` files in the `./old` folder.
6. Run `./old/pickle_dataset.py`.
7. Install LM Studio server with the `qwen2.5-coder-3b-instruct` model.
8. Run `./old/updateBCB.pkl.py` (**Warning:** long processing time).
9. Run `clustering_kmeans.py`.
10. Run `cosine_similarity.py`.
11. Run `produce_new_dataset.py`.

---

## How the New Dataset Was Created

- `matching_rows_true_positives.csv` — Verified code clones.
- `matching_rows_true_negatives.csv` — Verified non-clones.
- `matching_rows_false_positives.csv` — Code pairs previously marked as clones, but now considered non-clones.
- `matching_rows_false_negatives.csv` — Code pairs previously marked as non-clones, but now considered clones.

---

## Types of Code Clones

- **Type-1 (Textual similarity):** Code fragments that are identical except for differences in whitespace, layout, or comments.
- **Type-2 (Lexical similarity):** Code fragments that are identical except for differences in identifier names and literal values, in addition to Type-1 differences.
- **Type-3 (Syntactic similarity):** Code fragments with similar structure at the statement level. They may have added, modified, or removed statements compared to each other, along with Type-1 and Type-2 differences.
- **Type-4 (Semantic similarity):** Code fragments that are syntactically different but implement the same functionality.

---

# Wersja polska poniżej

## Repo, którego celem była reprodukcja 2 sposobów znajdywania sklonowanych części kodu. - Zrobione
## Dalszy cel, który został odkryty po analizie danych: naprawa datasetu BigCloneBench, który zawiera wiele przykładów nieoznaczonych jako klony, mimo że są to klony typu 4.

Aktualnie najlepiej działające podejście: grupowanie (KNN) po embeddingach krótkich opisów kawałków kodu wygenerowanych przez LLM.

![](clusterization_results.png)

- **False positives:** Przykłady oznaczone w datasecie jako klony, a klasteryzacja i odległość cosinusowa twierdzą inaczej.
- **False negatives:** Przykłady oznaczone w datasecie jako nieklony, a klasteryzacja i odległość cosinusowa twierdzą inaczej.
- **Rozmiar datasetu:** 540 000 rekordów

---

## Reprodukcja

https://drive.google.com/drive/u/1/folders/1DKLOvjTinMGJLjMlA5YTlAaBtNWju8jb

1. Pobrać repozytorium.
2. Przywrócić środowisko pythonowe z pliku `pyproject.toml`.
   - **Wskazówka:** Aby pominąć kroki 3-8 (czasochłonne), pobierz `BCB_updated.pkl` z powyższego Google Drive i umieść w folderze `./old`.
3. Pobrać początkowy dataset `id2sourcecode.zip` oraz pliki z labelami `BCB_clone.csv` i `BCB_nonclone.csv`.
4. Wypakować dataset do folderu `./old/dataset/id2sourcecode`.
5. Umieścić pliki `.csv` w folderze `./old`.
6. Uruchomić `./old/pickle_dataset.py`.
7. Zainstalować LM Studio server z modelem `qwen2.5-coder-3b-instruct`.
8. Uruchomić `./old/updateBCB.pkl.py` (**Uwaga:** długi czas przetwarzania).
9. Uruchomić `clustering_kmeans.py`.
10. Uruchomić `cosine_similarity.py`.
11. Uruchomić `produce_new_dataset.py`.

---

## Sposób utworzenia nowego datasetu

- `matching_rows_true_positives.csv` — Zawiera zweryfikowane klony.
- `matching_rows_true_negatives.csv` — Zawiera zweryfikowane nieklony.
- `matching_rows_false_positives.csv` — Pary kodów wcześniej oznaczone jako klony, a obecnie jako nieklony.
- `matching_rows_false_negatives.csv` — Pary kodów wcześniej oznaczone jako nieklony, a obecnie jako klony.

---

## Typy klonów kodu

- **Typ-1 (podobieństwo tekstowe):** Fragmenty kodu, które są identyczne, z wyjątkiem różnic w białych znakach, układzie i komentarzach.
- **Typ-2 (podobieństwo leksykalne):** Fragmenty kodu, które są identyczne, z wyjątkiem różnic w nazwach identyfikatorów i wartościach leksykalnych, oprócz różnic występujących w klonach typu 1.
- **Typ-3 (podobieństwo składniowe):** Fragmenty kodu wykazujące podobieństwa składniowe na poziomie instrukcji. Oprócz różnic typowych dla klonów typu 1 i 2, te fragmenty mogą mieć dodane, zmodyfikowane lub usunięte instrukcje względem siebie.
- **Typ-4 (podobieństwo semantyczne):** Fragmenty kodu, które są składniowo różne, ale realizują tę samą funkcjonalność.